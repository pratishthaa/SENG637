**SENG 637 - Dependability and Reliability of Software Systems**

**Lab. Report #3 – Code Coverage, Adequacy Criteria and Test Case Correlation**

| Group: 4      |
|-----------------|
| Student 1 Arpita Chowdhury                |   
| Student 2 Fadila Abdulai Hamid             |   
| Student 3 Kumkum Akter             |   
| Student 4 Niloofar Sharifisadr              |
| Student 5 Pratishtha Pratishtha |  


**Table of Contents**

[1 Introduction	1](#intro)

[2 Manual data-flow coverage calculations for X and Y methods](#man)

[3 A detailed description of the testing strategy for the new unit test](#testst)

[4 A high level description of five selected test cases you have designed using coverage information, and how they have increased code coverage](#hld)

[5 A detailed report of the coverage achieved of each class and method (a screen shot from the code cover results in green and red color would suffice)](#det)

[6 Pros and Cons of coverage tools used and Metrics you report](#pcon)

[7 A comparison on the advantages and disadvantages of requirements-based test generation and coverage-based test generation.](#diffe)

[8 A discussion on how the team work/effort was divided and managed](#team)

[9 Any difficulties encountered, challenges overcome, and lessons learned from performing the lab](#diff)

[10 Comments/feedback on the lab itself](#comm)


# 1 Introduction <a name="intro"></a>

Software testing is a critical component of the software development process, aiming to ensure the reliability, correctness, and robustness of software systems. In this assignment, our focus is on unit testing, specifically using JUnit, a popular testing framework in the Java ecosystem. Through this assignment, we delved into the principles of testing, with a particular emphasis on **white-box coverage criteria**, which help determine the adequacy of a test suite based on its coverage of the underlying code.

Our goal in this assignment is to write new test cases and utilize the test cases from the previous assignment to meet a predetermined code coverage. The `JFreeChart` package, which allows us to create charts in various ways, is the **system under test (SUT)**. It is an open-source Java framework available for free that calculates, creates, and displays charts. Numerous chart types are supported by this framework, such as histograms, pie charts, bar charts, line charts, and several others. The percentage of the source code that is covered while the test suite executes is the code coverage. JFreeChart makes it easy for developers to display professional charts in their applications. In Project 2, we created black-box test cases for ten distinct JFreeChart methods; five of them from the `Range class` and the other five from the `DataUtilities class`. 

Code coverage tools play a vital role in this process by providing insights into the extent to which the code is exercised by the test suite. Various coverage metrics, such as statement, branch, and condition coverages, aid in assessing the comprehensiveness of testing efforts. Additionally, we explored data-flow coverage criteria, such as DU pairs coverage, to deepen their understanding of how coverage tools work. In this assignment, we employ these test cases and test for their code coverage. We hope to achieve a minimum of 
  - 90% statement coverage.
  - 70% branch coverage.
  - 60%  method coverage.

For methods that we don't attain this defined code coverages, we have written new test cases to increase test coverage. For methods we obtain the minimum defined coverage, we have written more test cases for practice and improve ourselves at Software Testing.

In this report, throughout all sections, we will provide a detailed account of our testing strategy, including the selection of coverage metrics, the tools used for measuring coverage, and the challenges encountered during the testing process. We will discuss the advantages and limitations of different coverage tools, reflecting on their integration with IDEs, user-friendliness, and effectiveness in identifying gaps in test coverage apart from manual data flow coverage.

# 2 Manual data-flow coverage calculations for X and Y methods <a name="man"></a>

Text…

# 3 A detailed description of the testing strategy for the new unit test <a name="testst"></a>

Text…

# 4 A high level description of five selected test cases you have designed using coverage information, and how they have increased code coverage <a name="hld"></a>

Text…

# 5 A detailed report of the coverage achieved of each class and method (a screen shot from the code cover results in green and red color would suffice) <a name="det"></a>

Text…

# 6 Pros and Cons of coverage tools used and Metrics you report <a name="pcon"></a>

For this assignment, we have used `Eclemma` as our coverage tool, as it is already integrated in Eclipse and thus is easily accessible.

## Advantages of EclEmma:

**Seamless Integration with Eclipse:** EclEmma's integration with the Eclipse IDE is seamless, offering developers(like us here) a familiar environment for code coverage analysis without needing external tools.

**Intuitive User Interface:** With its user-friendly interface, EclEmma provides developers with clear and easy-to-understand coverage results, enhancing productivity and reducing the learning curve.

**Visual Code Highlighting:** EclEmma highlights code directly within the Eclipse editor, making it visually evident which lines are covered by tests and which are not, facilitating quick identification of untested code segments.

**Diverse Coverage Metrics:** Supporting a range of coverage metrics, including branch, line and method coverage, EclEmma empowers developers to select the most relevant metrics for assessing the comprehensiveness of their test suites.

**Comprehensive Reporting:** EclEmma generates comprehensive coverage reports, offering detailed insights into the extent of test coverage across the codebase. These reports aid in identifying areas requiring additional testing efforts.

## Limitations of EclEmma:

**Compatibility Challenges:** EclEmma may encounter compatibility issues with specific versions of Eclipse or other plugins, potentially leading to conflicts or unstable development environment.

**Performance Overhead:** Instrumenting code for coverage analysis may introduce performance overhead, particularly in large or complex codebases, impacting the efficiency of the testing process.

**Limited Metric Support:** EclEmma may lack support for specific advanced coverage metrics, such as data flow coverage, limiting its suitability for comprehensive test coverage analysis in specific scenarios.

**IDE Dependency:** As EclEmma is tightly coupled with Eclipse, developers using other IDEs may not fully leverage its features, restricting its adoption among a broader software developers community.

**Missing Advanced Features:** Compared to standalone coverage tools, EclEmma may need more advanced features and customization options, constraining its flexibility for specialized testing requirements, beyond the ones covered.

In terms of the types of coverage that `Eclemma` provides, we mostly focused on Method, line and branch coverage. 

## **Pros and Cons of EclEmma's Method, Line, and Branch Coverage:**

### **Method Coverage:**

**Pros:**

**High-Level View:** Provides a broad overview of tested methods, aiding in identifying untested areas efficiently.

**Simplicity:** Easy to understand and implement, suitable for quick assessments of test suite effectiveness.

**Focus on Core Functionality:** Prioritizes testing of essential functionalities within the codebase.

**Cons:**

**Limited Granularity:** Doesn't differentiate between different execution paths within methods.

**Inadequate for Complex Methods:** May not capture all execution scenarios in complex methods.

### **Line Coverage:**

**Pros:**

**Granular Insights:** Offers detailed insights into tested code lines, facilitating pinpointing areas requiring additional testing.

**Accurate Assessment:** Provides a more accurate assessment of test suite effectiveness compared to method coverage.

**Detection of Dead Code:** Helps detect and eliminate redundant or unreachable code segments.

**Cons:**

**Overemphasis on Syntax:** May prioritize syntax coverage over functional behavior.

**Complexity Overhead:** Achieving high line coverage may increase testing effort and maintenance burden.

### **Branch Coverage:**

**Pros:**

**Path Exploration:** Explores different execution paths within conditional statements, ensuring comprehensive testing.

**Detection of Missing Conditions:** Identifies gaps in test coverage within conditional statements.

**Enhanced Quality Assurance:** Reduces the likelihood of overlooking critical decision points or logic errors.

**Cons:**

**Complexity Management:** Testing intricate branching structures may require extensive efforts.

**False Sense of Completeness:** Does not guarantee exhaustive testing within branches, risking incomplete coverage.








# 7 A comparison on the advantages and disadvantages of requirements-based test generation and coverage-based test generation. <a name="diffe"></a>

Text…

# 8 A discussion on how the team work/effort was divided and managed <a name="team"></a>

Text…

# 9 Any difficulties encountered, challenges overcome, and lessons learned from performing the lab <a name="diff"></a>

Text…

# 10 Comments/feedback on the lab itself <a name="comm"></a>

Text…

